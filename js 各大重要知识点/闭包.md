[作用域/作用链](https://github.com/KenNaNa/big-frontend-knowlage/blob/master/js%20%E5%90%84%E5%A4%A7%E9%87%8D%E8%A6%81%E7%9F%A5%E8%AF%86%E7%82%B9/%E4%BD%9C%E7%94%A8%E5%9F%9F.md)

我们知道，`js` 在执行之前会有词法解析，语法解析，以及代码生成

会产生作用域链

上面那个例子是：

```js
var a = 1
function foo() {
    var a = 2
    function bar() {
        console.log("bar ===>", a)
        console.log("bar ===>",this)
    }
    console.log("foo", this)
    bar()
}
foo()
```

`bar` 执行能访问到 `foo` 作用域中的 `a` 变量，是因为作用域链的存在，才致使 `bar()` 执行过程中找到了 `foo` 作用域中的 `a` 变量，这就说明一个重要的问题：

**`bar` 保存着 `foo` 中的变量**

函数执行完毕，里面所有的变量，函数，内存，正常来说会销毁，也不会存在作用域链这一问题。

但是有一个特殊的点就是：

# 闭包

我们来举个例子，上面代码中 `bar()` ，在以下这个例子中，我们不在 `foo` 作用域里面执行，直接返回：

```js
var a = 1
function foo() {
    var a = 2
    function bar() {
        console.log("bar ===>", a)
        console.log("bar ===>",this)
    }
    console.log("foo", this)
    return bar
}
var bar = foo()
bar()
```

以下执行打印出来：

```js
foo Window
bar====> 2
bar====> Window
```

我们在上面一节课得出，函数执行完毕就销毁，但是这个例子中的 `bar` 还没执行，只是在 `foo` 作用域中定义了，但是不执行，没有销毁，

只是改变了执行环境而已，`bar` 作用域仍然保存着 `foo` 作用域的一系列东西，变量什么的，

所以在全局作用域中执行 `bar()`，任然会打印出 `bar===2`

**所以我们可以总结出，闭包其实是在原来的作用域中定义，然后脱离了原来的作用域，在其他的作用域执行，此时闭包还存在其原始定义时作用域的变量**


# 网上的说法

js的声明提升：在函数作用域内的任何变量的声明都会被提升到顶部并且是`undeinfed`值。
所以`JavaScript`引擎解释同样的脚本文件两次？做完所有的声明提升然后执行代码？还是先编译整个代码然后运行它？这两种情况都不对。

下面是js处理声明的过程：
一旦`V8`引擎进入一个执行具体代码的执行上下文（函数），它就对代码进行词法分析或者分词。这意味着代码将被分割成像`foo = 10`这样的原子标记。
在对当前的整个作用域分析完成后，引擎将解析成一个AST（抽象语法书）的翻译版本。
引擎每一次遇到声明，它就把声明传到作用域来创建一个绑定。对每一次声明它都会为变量分配内存。只是分配内存而不是把代码修改成声明提升。正如你所知道的，在JS中分配内存意味着将默认值设为undefined。
在这之后，引擎每一次遇到赋值或者取值，它都会通过作用域查找绑定。如果在当前作用域中没有查找到就接着向上级作用域查找直到找到为止。
接着引擎生成`CPU`可以执行的机器码。
最后， 代码执行完毕。


# 闭包




